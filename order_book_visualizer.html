<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Binance Order Book Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white">
    <div id="root">
        <div class="min-h-screen bg-gray-900 text-gray-200 flex flex-col font-sans">
            <header class="p-4 bg-gray-800 border-b border-gray-700 shadow-lg flex flex-wrap items-center justify-between gap-4">
                <h1 class="text-2xl font-bold text-cyan-400">Order Book Visualizer</h1>
                <div class="flex items-center gap-3">
                    <div class="relative" id="symbol-search-container">
                        <input id="symbol-search-input" type="text" placeholder="Select a pair..." class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 w-48 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 disabled:opacity-50" autocomplete="off">
                        <div id="symbol-dropdown" class="absolute z-10 mt-1 w-full bg-gray-800 border border-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto hidden">
                            <div id="symbol-dropdown-list">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                    <select id="frequency-select" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 disabled:opacity-50" aria-label="Update Frequency">
                        <option value="100ms" selected>100ms (High Freq)</option>
                        <option value="1000ms">1000ms (Low Freq)</option>
                    </select>
                    <button id="connect-button" class="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-md font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-cyan-500 disabled:bg-gray-600">
                        Connect
                    </button>
                    <button id="disconnect-button" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-md font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-red-500 hidden">
                        Disconnect
                    </button>
                    <button id="info-button" class="p-2 bg-gray-700 hover:bg-gray-600 rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-cyan-500">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </button>
                </div>
            </header>

            <main id="main-content" class="flex-grow flex flex-col items-center justify-center p-4">
                <div id="status-disconnected" class="text-center">
                    <h2 class="text-3xl font-light">Welcome</h2>
                    <p class="text-gray-400 mt-2">Select a trading pair and press 'Connect' to begin visualizing the order book.</p>
                </div>
                <div id="status-connecting" class="flex flex-col items-center gap-4 hidden">
                    <div id="spinner">
                        <svg class="animate-spin h-10 w-10 text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <p id="connecting-text" class="text-lg text-gray-400">Connecting...</p>
                </div>
                <div id="status-error" class="text-center text-red-400 hidden">
                    <h2 class="text-2xl">Connection Error</h2>
                    <p>Could not connect to the WebSocket stream. Please try again.</p>
                </div>
                <div id="visualizer-container" class="w-full h-[calc(100vh-170px)] flex flex-col hidden">
                    <div class="flex justify-between items-center mb-2 px-2 flex-wrap gap-y-2">
                        <div class="flex items-center gap-4">
                            <span id="symbol-display" class="text-xl font-mono text-cyan-400"></span>
                            <div class="flex items-center gap-1 p-1 bg-gray-800 border border-gray-700 rounded-md">
                                <button data-type="book" class="viz-type-btn px-3 py-1 text-sm rounded-md transition-colors text-gray-300 hover:bg-gray-600">
                                    Book
                                </button>
                                <button data-type="walls" class="viz-type-btn px-3 py-1 text-sm rounded-md transition-colors bg-cyan-600 text-white">
                                    Walls
                                </button>
                            </div>
                        </div>
                        <span class="text-lg font-mono text-gray-400 hidden md:inline">Use mouse wheel to zoom, click and drag to pan.</span>
                        <span class="text-xl font-mono">
                            Price: <span id="price-display" class="text-yellow-300">0.0000</span>
                        </span>
                    </div>
                    <div id="canvas-parent" class="flex-grow w-full border border-gray-700 rounded-lg overflow-hidden">
                    </div>
                </div>
            </main>
        </div>
    </div>

    <div id="info-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto p-6 border border-gray-700 relative">
            <button id="close-modal-button" class="absolute top-4 right-4 text-gray-400 hover:text-white">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <h2 class="text-2xl font-bold text-cyan-400 mb-4">About the Order Book Visualizer</h2>
            <div class="space-y-4 text-gray-300">
                <p>This application provides a real-time, high-frequency visualization of the Binance spot market order book. It connects directly to Binance's WebSocket streams to render a pixel-by-pixel history of order book depth and market activity.</p>
                
                <div>
                    <h3 class="text-xl font-semibold text-cyan-500 mb-2">Visualization Modes</h3>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong class="font-semibold text-white">Book:</strong> Displays a full heatmap of the order book. The <span class="text-red-400">hotter</span> the color (red/yellow), the higher the volume at that price level. The <span class="text-blue-400">colder</span> the color (blue/purple), the lower the volume.</li>
                        <li><strong class="font-semibold text-white">Walls:</strong> Filters the heatmap to show only statistically significant large orders ("walls") that could act as price support or resistance. This mode also enables advanced event tracking.</li>
                    </ul>
                </div>

                <div>
                    <h3 class="text-xl font-semibold text-cyan-500 mb-2">Event Markers (Walls Mode)</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="flex items-start gap-3">
                            <div class="w-8 h-8 flex-shrink-0 flex items-center justify-center">
                                <span class="text-yellow-300 text-lg font-bold">● 85%</span>
                            </div>
                            <div>
                                <h4 class="font-semibold text-white">Eaten Wall</h4>
                                <p class="text-sm">Indicates a large order wall was consumed by market trades rather than being canceled ("spoofed"). The percentage shows how much of the wall's volume was traded through.</p>
                            </div>
                        </div>
                         <div class="flex items-start gap-3">
                            <div class="w-8 h-8 flex-shrink-0 flex items-center justify-center">
                                <span class="text-green-500 text-2xl font-bold">▲</span>
                            </div>
                            <div>
                                <h4 class="font-semibold text-white">Support Bounce</h4>
                                <p class="text-sm">Indicates the price approached a large buy wall (support) and then reversed, suggesting the wall held the price up.</p>
                            </div>
                        </div>
                         <div class="flex items-start gap-3">
                            <div class="w-8 h-8 flex-shrink-0 flex items-center justify-center">
                                <span class="text-red-500 text-2xl font-bold">▼</span>
                            </div>
                            <div>
                                <h4 class="font-semibold text-white">Resistance Bounce</h4>
                                <p class="text-sm">Indicates the price approached a large sell wall (resistance) and then reversed, suggesting the wall pushed the price down.</p>
                            </div>
                        </div>
                    </div>
                </div>
                 <div>
                    <h3 class="text-xl font-semibold text-cyan-500 mb-2">Controls</h3>
                    <ul class="list-disc list-inside space-y-1">
                        <li><strong class="font-semibold text-white">Zoom:</strong> Use the mouse scroll wheel over the chart.</li>
                        <li><strong class="font-semibold text-white">Pan:</strong> Click and drag the chart vertically.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- DATA MANAGER (formerly useBinanceOrderBook hook) ---
        function createOrderBookManager() {
            const WALL_THRESHOLD_MULTIPLIER = 10;
            const EATEN_WALL_TRADE_PERCENTAGE = 0.8;
            const BOUNCE_PROXIMITY_TICKS = 5;
            const BOUNCE_REJECTION_TICKS = 7;

            let state = {
                status: 'disconnected',
                currentPrice: 0,
                updateCounter: 0,
                eatenWallEvents: [],
                bounceEvents: [],
                orderBook: null,
                initialViewParams: null,
            };

            let depthWs = null;
            let tradeWs = null;
            let lastUpdateId = 0;
            let activeWalls = new Map();
            let onUpdateCallback = () => {};
            let currentSymbol = '';
            let currentVizType = 'walls';
            let currentTickSize = 0;
            let currentFrequency = '100ms';

            const setState = (newState) => {
                state = { ...state, ...newState };
                onUpdateCallback(state);
            };

            const calculateInitialRange = async (symbol) => {
                try {
                    const klinesResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol.toUpperCase()}&interval=1m&limit=10`);
                    if (!klinesResponse.ok) throw new Error('Failed to fetch klines');
                    const klines = await klinesResponse.json();
                    if (klines.length === 0) throw new Error('No kline data available');
                    
                    let highestHigh = 0;
                    let lowestLow = Infinity;
                    klines.forEach(kline => {
                        const high = parseFloat(kline[2]);
                        const low = parseFloat(kline[3]);
                        if (high > highestHigh) highestHigh = high;
                        if (low < lowestLow) lowestLow = low;
                    });
                    const volatility = highestHigh - lowestLow;
                    
                    const priceResponse = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol.toUpperCase()}`);
                    if (!priceResponse.ok) throw new Error('Failed to fetch ticker price');
                    const priceData = await priceResponse.json();
                    const centerPrice = parseFloat(priceData.price);

                    return { volatility, centerPrice };
                } catch (error) {
                    console.error(`Could not calculate initial range for ${symbol}:`, error);
                    return { volatility: 0, centerPrice: 0 };
                }
            };
            
            const processUpdates = (side, updates) => {
              for (const [price, quantity] of updates) {
                if (parseFloat(quantity) === 0) {
                  side.delete(price);
                } else {
                  side.set(price, quantity);
                }
              }
            };

            const handleWallAndBounceTracking = () => {
                const { orderBook, currentPrice, updateCounter } = state;
                if (!orderBook) return;

                const allVolumes = [
                    ...Array.from(orderBook.bids.values()),
                    ...Array.from(orderBook.asks.values())
                ].map(parseFloat).filter(v => v > 0);
                
                if (allVolumes.length === 0) return;

                const avgVolume = allVolumes.reduce((sum, v) => sum + v, 0) / allVolumes.length;
                const wallThreshold = avgVolume * WALL_THRESHOLD_MULTIPLIER;
                
                const currentWalls = new Set();
                const processSide = (side, sideName) => {
                    side.forEach((quantity, priceStr) => {
                        const volume = parseFloat(quantity);
                        if (volume > wallThreshold) {
                            currentWalls.add(priceStr);
                            if (!activeWalls.has(priceStr)) {
                                activeWalls.set(priceStr, {
                                    price: parseFloat(priceStr),
                                    side: sideName,
                                    initialVolume: volume,
                                    lastSeenVolume: volume,
                                    cumulativeTradeVolume: 0,
                                    firstSeenUpdate: updateCounter,
                                    proximityState: 'far',
                                });
                            } else {
                                const wall = activeWalls.get(priceStr);
                                wall.lastSeenVolume = volume;
                            }
                        }
                    });
                };
                processSide(orderBook.bids, 'bid');
                processSide(orderBook.asks, 'ask');
                
                activeWalls.forEach((wall, priceStr) => {
                    if (!currentWalls.has(priceStr)) { // Wall removed
                        const tradedPercentage = wall.initialVolume > 0 ? wall.cumulativeTradeVolume / wall.initialVolume : 0;
                        if (tradedPercentage >= EATEN_WALL_TRADE_PERCENTAGE) {
                            const newEvent = {
                                id: `${wall.price}-${wall.firstSeenUpdate}`,
                                price: wall.price,
                                tradedPercentage: Math.min(tradedPercentage, 1),
                                updateCounter: updateCounter,
                            };
                            setState({ eatenWallEvents: [...state.eatenWallEvents, newEvent] });
                        }
                        activeWalls.delete(priceStr);
                    } else { // Wall exists, check bounce
                        if(currentTickSize <= 0) return;
                        const proximityThreshold = BOUNCE_PROXIMITY_TICKS * currentTickSize;
                        const rejectionThreshold = BOUNCE_REJECTION_TICKS * currentTickSize;

                        let bounceDetected = false;
                        if (wall.side === 'ask') {
                            const distance = wall.price - currentPrice;
                            if (wall.proximityState === 'far' && distance > 0 && distance <= proximityThreshold) {
                                wall.proximityState = 'close';
                            } else if (wall.proximityState === 'close' && distance > rejectionThreshold) {
                                bounceDetected = true;
                                wall.proximityState = 'far';
                            }
                        } else { // bid
                            const distance = currentPrice - wall.price;
                            if (wall.proximityState === 'far' && distance > 0 && distance <= proximityThreshold) {
                                wall.proximityState = 'close';
                            } else if (wall.proximityState === 'close' && distance > rejectionThreshold) {
                                bounceDetected = true;
                                wall.proximityState = 'far';
                            }
                        }

                        if(bounceDetected) {
                            const newEvent = {
                                id: `${wall.price}-${updateCounter}`,
                                price: wall.price,
                                side: wall.side,
                                updateCounter: updateCounter
                            };
                            setState({ bounceEvents: [...state.bounceEvents, newEvent] });
                        }
                    }
                });
            };

            const connect = async (symbol, vizType, tickSize, frequency) => {
                if (state.status !== 'disconnected' && state.status !== 'error') return;

                manager.disconnect(); 
                currentSymbol = symbol;
                currentVizType = vizType;
                currentTickSize = tickSize;
                currentFrequency = frequency;
                setState({ status: 'connecting', updateCounter: 0, orderBook: null, initialViewParams: null });
                
                const initialViewParams = await calculateInitialRange(symbol);
                state.initialViewParams = initialViewParams;

                const eventBuffer = [];
                let isProcessingBuffer = true;

                if (currentVizType === 'walls') {
                    tradeWs = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@aggTrade`);
                    tradeWs.onmessage = (event) => {
                        const trade = JSON.parse(event.data);
                        const tradePrice = parseFloat(trade.p);
                        const tradeQty = parseFloat(trade.q);
                        
                        activeWalls.forEach(wall => {
                            if (wall.side === 'bid' && tradePrice <= wall.price) {
                                wall.cumulativeTradeVolume += tradeQty;
                            } else if (wall.side === 'ask' && tradePrice >= wall.price) {
                                wall.cumulativeTradeVolume += tradeQty;
                            }
                        });
                    };
                    tradeWs.onerror = (err) => console.error("Trade WebSocket Error:", err);
                }

                depthWs = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth@${frequency}`);
                
                const handleSyncFailure = () => {
                    console.error("Order book sync failed. Closing connection to trigger reconnect.");
                    if(depthWs) depthWs.close();
                };

                depthWs.onmessage = (event) => {
                    const update = JSON.parse(event.data);

                    if (isProcessingBuffer) {
                        eventBuffer.push(update);
                        return;
                    }
                    
                    if (lastUpdateId === 0) {
                        return; // Wait for snapshot to be fully processed
                    }

                    // Gap detection: if the first update ID is greater than the last one + 1, we missed messages.
                    if (update.U > lastUpdateId + 1) {
                        handleSyncFailure();
                        return;
                    }

                    // Process only if the update is new (its final ID is after our last known ID)
                    if (update.u >= lastUpdateId + 1) {
                        if (state.orderBook) {
                            processUpdates(state.orderBook.bids, update.b);
                            processUpdates(state.orderBook.asks, update.a);

                            const bestBid = Math.max(...Array.from(state.orderBook.bids.keys()).map(parseFloat));
                            const bestAsk = Math.min(...Array.from(state.orderBook.asks.keys()).map(parseFloat));
                            let newPrice = state.currentPrice;
                            if(isFinite(bestBid) && isFinite(bestAsk)) {
                                newPrice = (bestBid + bestAsk) / 2;
                            }
                            
                            setState({
                                updateCounter: state.updateCounter + 1,
                                currentPrice: newPrice,
                                orderBook: state.orderBook,
                            });
                            
                            if (currentVizType === 'walls') {
                                handleWallAndBounceTracking();
                            }
                        }
                        lastUpdateId = update.u;
                    }
                };
                
                const fetchAndProcessSnapshot = async () => {
                    try {
                        const response = await fetch(`https://api.binance.com/api/v3/depth?symbol=${symbol.toUpperCase()}&limit=500`);
                        if (!response.ok) throw new Error('Failed to fetch snapshot');
                        const snapshot = await response.json();
                        const snapshotLastUpdateId = snapshot.lastUpdateId;

                        const bids = new Map(snapshot.bids);
                        const asks = new Map(snapshot.asks);
                        const newOrderBook = { bids, asks };

                        const bestBid = Math.max(...Array.from(newOrderBook.bids.keys()).map(parseFloat));
                        const bestAsk = Math.min(...Array.from(newOrderBook.asks.keys()).map(parseFloat));
                        const snapshotMidPrice = (isFinite(bestBid) && isFinite(bestAsk)) ? (bestBid + bestAsk) / 2 : 0;
                        const initialPrice = state.initialViewParams?.centerPrice > 0 ? state.initialViewParams.centerPrice : snapshotMidPrice;
                        
                        let firstValidUpdateIndex = -1;
                        for(let i = 0; i < eventBuffer.length; i++) {
                            const update = eventBuffer[i];
                             if (update.u > snapshotLastUpdateId) {
                                firstValidUpdateIndex = i;
                                break;
                            }
                        }

                        if (firstValidUpdateIndex === -1) {
                             // None of the buffered events are new enough, wait for live events
                            lastUpdateId = snapshotLastUpdateId;
                            isProcessingBuffer = false;
                            eventBuffer.length = 0;
                            setState({ 
                                status: 'connected', 
                                orderBook: newOrderBook, 
                                updateCounter: 1,
                                currentPrice: initialPrice,
                                initialViewParams: state.initialViewParams
                            });
                            return;
                        }
                        
                        // Check if we missed an update between snapshot and the first valid buffered event
                        if (eventBuffer[firstValidUpdateIndex].U > snapshotLastUpdateId + 1) {
                            handleSyncFailure();
                            return;
                        }

                        for (let i = firstValidUpdateIndex; i < eventBuffer.length; i++) {
                            const update = eventBuffer[i];
                            processUpdates(newOrderBook.bids, update.b);
                            processUpdates(newOrderBook.asks, update.a);
                            lastUpdateId = update.u;
                        }

                        isProcessingBuffer = false;
                        eventBuffer.length = 0;
                        setState({
                            status: 'connected', 
                            orderBook: newOrderBook, 
                            updateCounter: 1,
                            currentPrice: initialPrice,
                            initialViewParams: state.initialViewParams
                        });

                    } catch (error) {
                        console.error("Connection failed:", error);
                        setState({ status: 'error' });
                        manager.disconnect();
                    }
                };

                depthWs.onopen = () => fetchAndProcessSnapshot();
                depthWs.onerror = (err) => {
                    console.error("Depth WebSocket Error:", err);
                    setState({ status: 'error' });
                };
                depthWs.onclose = () => {
                    if (state.status === 'connected' || state.status === 'connecting') {
                        console.log("WebSocket closed unexpectedly. Reconnecting in 2 seconds...");
                        const reconnectSymbol = currentSymbol;
                        manager.disconnect();
                        setTimeout(() => manager.connect(reconnectSymbol, currentVizType, currentTickSize, currentFrequency), 2000);
                    }
                };
            };
            
            const manager = {
                onUpdate(callback) {
                    onUpdateCallback = callback;
                },
                connect,
                disconnect() {
                    if (depthWs) {
                        depthWs.onclose = null; 
                        depthWs.close();
                    }
                    if (tradeWs) {
                        tradeWs.onclose = null;
                        tradeWs.close();
                    }
                    depthWs = null;
                    tradeWs = null;
                    lastUpdateId = 0;
                    activeWalls.clear();
                    setState({
                        status: 'disconnected',
                        currentPrice: 0,
                        updateCounter: 0,
                        eatenWallEvents: [],
                        bounceEvents: [],
                        orderBook: null,
                    });
                }
            };
            return manager;
        }

        // --- VISUALIZER CLASS (formerly OrderBookVisualizer component) ---
        class OrderBookVisualizer {
            constructor(parentElementId) {
                const parent = document.getElementById(parentElementId);
                if (!parent) throw new Error('Parent element not found');

                this.container = document.createElement('div');
                this.container.className = 'relative w-full h-full bg-gray-900';
                
                this.canvas = document.createElement('canvas');
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';

                this.overlayCanvas = document.createElement('canvas');
                this.overlayCanvas.className = 'absolute top-0 left-0 cursor-crosshair';
                this.overlayCanvas.style.width = '100%';
                this.overlayCanvas.style.height = '100%';
                
                this.container.appendChild(this.canvas);
                this.container.appendChild(this.overlayCanvas);
                parent.appendChild(this.container);

                this.ctx = this.canvas.getContext('2d');
                this.overlayCtx = this.overlayCanvas.getContext('2d');
                
                this.dimensions = { width: 0, height: 0, dpr: 1 };
                this.priceView = null;
                this.history = [];
                
                this.isDragging = false;
                this.dragStart = null;
                this.mouseY = null;
                this.latestProps = null;
                
                this.initEventListeners();
            }

            initEventListeners() {
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const { width, height } = entry.contentRect;
                        const dpr = window.devicePixelRatio || 1;
                        this.dimensions = { width, height, dpr };
                        
                        this.canvas.width = this.overlayCanvas.width = width * dpr;
                        this.canvas.height = this.overlayCanvas.height = height * dpr;
                        
                        this.ctx.scale(dpr, dpr);
                        this.overlayCtx.scale(dpr, dpr);

                        // Trim history if canvas shrinks
                        const chartWidth = width - 80; // RIGHT_PADDING
                        if (this.history.length > chartWidth) {
                            this.history.splice(0, this.history.length - chartWidth);
                        }
                        this.redraw();
                    }
                });
                resizeObserver.observe(this.container.parentElement);

                this.overlayCanvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.overlayCanvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));
                this.overlayCanvas.addEventListener('wheel', this.handleWheel.bind(this));
                this.overlayCanvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.overlayCanvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                window.addEventListener('mouseup', () => {
                    if(this.isDragging) this.handleMouseUp({ currentTarget: this.overlayCanvas });
                });
            }

            handleWheel(event) {
                event.preventDefault();
                if (!this.priceView) return;
                const { min, max } = this.priceView;
                const { height } = this.dimensions;
                if (height <= 0) return;

                const range = max - min;
                const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
                const cursorY = event.offsetY;
                
                const priceAtCursor = max - (cursorY / height) * range;
                const newRange = range * zoomFactor;
                
                this.priceView = {
                    min: priceAtCursor - (1 - cursorY / height) * newRange,
                    max: priceAtCursor + (cursorY / height) * newRange
                };
                this.redraw();
            }

            handleMouseDown(event) {
                if (event.button !== 0 || !this.priceView) return;
                this.isDragging = true;
                this.dragStart = { y: event.offsetY, view: { ...this.priceView } };
                event.currentTarget.style.cursor = 'grabbing';
            }
            
            handleMouseUp(event) {
                this.isDragging = false;
                this.dragStart = null;
                event.currentTarget.style.cursor = 'crosshair';
            }

            handleMouseMove(event) {
                this.mouseY = event.offsetY;
                if (this.isDragging && this.dragStart && this.priceView) {
                    const { y: startY, view: startView } = this.dragStart;
                    const { height } = this.dimensions;
                    if(height <= 0) return;

                    const deltaY = this.mouseY - startY;
                    const range = startView.max - startView.min;
                    const priceDelta = (deltaY / height) * range;

                    this.priceView = {
                        min: startView.min + priceDelta,
                        max: startView.max + priceDelta,
                    };
                    this.redraw();
                } else if (this.latestProps) {
                    this.drawOverlay(this.latestProps);
                }
            }

            handleMouseLeave() {
                this.mouseY = null;
                if (this.isDragging) this.handleMouseUp({ currentTarget: this.overlayCanvas });
                if (this.latestProps) {
                    this.drawOverlay(this.latestProps);
                }
            }

            volumeToColor(volume, maxLogVolume) {
                if (volume <= 0 || maxLogVolume <= 0) return 'hsl(240, 100%, 5%)';
                const logVolume = Math.log1p(volume);
                const normalized = Math.min(logVolume / maxLogVolume, 1);
                const hue = 240 * (1 - normalized);
                return `hsl(${hue}, 100%, 50%)`;
            }

            render(props) {
                this.latestProps = props;
                const { orderBook, currentPrice, updateCounter, initialViewParams } = props;
                
                if (updateCounter === 0) {
                    this.history = [];
                    this.priceView = null;
                }
                
                if (updateCounter === 1 && orderBook) {
                    if (initialViewParams && initialViewParams.volatility > 0 && currentPrice > 0) {
                        const centerPrice = currentPrice;
                        const volatilityRange = initialViewParams.volatility;
                        const minRange = centerPrice * 0.002;
                        const finalRange = Math.max(volatilityRange, minRange);
                        this.priceView = {
                            min: centerPrice - finalRange / 2,
                            max: centerPrice + finalRange / 2,
                        };
                    } else {
                        const allPrices = [...orderBook.bids.keys(), ...orderBook.asks.keys()].map(parseFloat);
                        if (allPrices.length > 0) {
                            const min = Math.min(...allPrices);
                            const max = Math.max(...allPrices);
                            let range = max - min;
                            if (range === 0) range = Math.max(max * 0.001, 0.0001);
                            this.priceView = { min: min - range * 0.2, max: max + range * 0.2 };
                        }
                    }
                }

                const lastUpdateInHistory = this.history.length > 0 ? this.history[this.history.length - 1].updateCounter : -1;
                if (orderBook && updateCounter > lastUpdateInHistory) {
                    this.history.push({
                        updateCounter,
                        orderBook: {
                            bids: new Map(orderBook.bids),
                            asks: new Map(orderBook.asks),
                        },
                        currentPrice,
                    });
                    
                    const { width } = this.dimensions;
                    const chartWidth = width - 80; // RIGHT_PADDING
                    if (chartWidth > 0 && this.history.length > chartWidth) {
                        this.history.shift();
                    }
                }
                
                this.redraw();
            }
            
            redraw() {
                if (!this.latestProps || !this.canvas || !this.priceView) {
                    if (this.overlayCtx && this.dimensions.width > 0) {
                        this.overlayCtx.clearRect(0, 0, this.dimensions.width, this.dimensions.height);
                    }
                    return;
                }

                const { visualizationType, eatenWallEvents, bounceEvents } = this.latestProps;
                const RIGHT_PADDING = 80;
                
                const { width, height } = this.dimensions;
                const chartWidth = width - RIGHT_PADDING;
                if (width <= 0 || height <= 0 || chartWidth <= 0) return;

                this.ctx.clearRect(0, 0, width, height);

                const { min: displayMinPrice, max: displayMaxPrice } = this.priceView;
                const priceRange = displayMaxPrice - displayMinPrice;
                if (priceRange <= 0) return;

                const updateCounterToX = new Map();

                this.history.forEach((frame, i) => {
                    const x = chartWidth - this.history.length + i;
                    if (x < 0) return;
                    
                    updateCounterToX.set(frame.updateCounter, x);

                    const { orderBook, currentPrice } = frame;
                    const allVolumes = [...orderBook.bids.values(), ...orderBook.asks.values()].map(parseFloat);
                    if (allVolumes.length === 0) return;

                    const maxLogVolume = Math.log1p(Math.max(...allVolumes));
                    if (maxLogVolume <= 0) return;

                    let wallThreshold = 0;
                    if (visualizationType === 'walls') {
                        const validVolumes = allVolumes.filter(v => v > 0);
                        if(validVolumes.length > 0) {
                            wallThreshold = (validVolumes.reduce((s, v) => s + v, 0) / validVolumes.length) * 10;
                        }
                    }
                    
                    const pixelVolumes = new Map();
                    const processSide = (side) => {
                        side.forEach((quantity, priceStr) => {
                            const price = parseFloat(priceStr);
                            const volume = parseFloat(quantity);
                            const y = Math.floor(((displayMaxPrice - price) / priceRange) * height);
                            if (y >= 0 && y < height) {
                                pixelVolumes.set(y, (pixelVolumes.get(y) || 0) + volume);
                            }
                        });
                    };
                    processSide(orderBook.bids);
                    processSide(orderBook.asks);
                    
                    pixelVolumes.forEach((volume, y) => {
                        if (visualizationType === 'book' || (visualizationType === 'walls' && volume >= wallThreshold)) {
                            this.ctx.fillStyle = this.volumeToColor(volume, maxLogVolume);
                            this.ctx.fillRect(x, y, 1, 1);
                        }
                    });

                    if (currentPrice >= displayMinPrice && currentPrice <= displayMaxPrice) {
                        const priceY = Math.floor(((displayMaxPrice - currentPrice) / priceRange) * height);
                        if (priceY >= 0 && priceY < height) {
                            this.ctx.fillStyle = 'rgb(255, 255, 255)';
                            this.ctx.fillRect(x, priceY, 1, 1);
                        }
                    }
                });
                
                if (visualizationType === 'walls') {
                    eatenWallEvents.forEach(event => {
                        const x = updateCounterToX.get(event.updateCounter);
                        if (x === undefined || x < 0 || x > chartWidth) return;
                        
                        const y = Math.floor(((displayMaxPrice - event.price) / priceRange) * height);
                        if (y >= 0 && y < height) {
                            this.ctx.fillStyle = '#FFD700';
                            this.ctx.beginPath();
                            this.ctx.arc(x + 0.5, y, 3, 0, 2 * Math.PI);
                            this.ctx.fill();
                            this.ctx.font = '10px monospace';
                            this.ctx.textAlign = 'right';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillStyle = '#FFFFFF';
                            this.ctx.fillText(`${(event.tradedPercentage * 100).toFixed(0)}%`, x - 5, y);
                        }
                    });
                    
                    bounceEvents.forEach(event => {
                        const x = updateCounterToX.get(event.updateCounter);
                        if (x === undefined || x < 0 || x > chartWidth) return;
                        
                        const y = Math.floor(((displayMaxPrice - event.price) / priceRange) * height);
                        if (y >= 0 && y < height) {
                            this.ctx.beginPath();
                            if (event.side === 'bid') {
                                this.ctx.fillStyle = '#22c55e';
                                this.ctx.moveTo(x - 2, y + 5); this.ctx.lineTo(x + 3, y); this.ctx.lineTo(x - 7, y);
                            } else {
                                this.ctx.fillStyle = '#ef4444';
                                this.ctx.moveTo(x - 2, y - 5); this.ctx.lineTo(x + 3, y); this.ctx.lineTo(x - 7, y);
                            }
                            this.ctx.closePath();
                            this.ctx.fill();
                        }
                    });
                }
                
                this.drawOverlay(this.latestProps);
            }

            drawOverlay(props) {
                if (!props) return;
                const { currentPrice } = props;
                const { width, height } = this.dimensions;
                if(width <= 0 || height <= 0 || !this.priceView) {
                    this.overlayCtx.clearRect(0, 0, width, height);
                    return;
                }
                
                this.overlayCtx.clearRect(0, 0, width, height);
                const { min, max } = this.priceView;
                const range = max - min;
                if (range <= 0) return;
                
                this.overlayCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.overlayCtx.font = '12px monospace';
                this.overlayCtx.textAlign = 'right';
                this.overlayCtx.textBaseline = 'top';
                this.overlayCtx.fillText(max.toFixed(4), width - 5, 5);
                this.overlayCtx.textBaseline = 'bottom';
                this.overlayCtx.fillText(min.toFixed(4), width - 5, height - 5);
                
                if (currentPrice >= min && currentPrice <= max) {
                    const priceY = ((max - currentPrice) / range) * height;
                    this.overlayCtx.setLineDash([4, 2]);
                    this.overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    this.overlayCtx.lineWidth = 1;
                    this.overlayCtx.beginPath();
                    this.overlayCtx.moveTo(0, priceY);
                    this.overlayCtx.lineTo(width, priceY);
                    this.overlayCtx.stroke();
                    
                    const text = currentPrice.toFixed(4);
                    const textMetrics = this.overlayCtx.measureText(text);
                    const rectX = width - textMetrics.width - 8;
                    const rectY = Math.max(0, Math.min(height - 28, priceY - 14));
                    this.overlayCtx.fillStyle = 'rgba(120, 120, 120, 0.7)';
                    this.overlayCtx.fillRect(rectX, rectY, textMetrics.width + 8, 20);
                    this.overlayCtx.fillStyle = '#FFFFFF';
                    this.overlayCtx.textBaseline = 'middle';
                    this.overlayCtx.fillText(text, width - 4, rectY + 10);
                }
                
                if (this.mouseY !== null) {
                    this.overlayCtx.setLineDash([]);
                    this.overlayCtx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                    this.overlayCtx.beginPath();
                    this.overlayCtx.moveTo(0, this.mouseY);
                    this.overlayCtx.lineTo(width, this.mouseY);
                    this.overlayCtx.stroke();

                    const hoverPrice = max - (this.mouseY / height) * range;
                    const text = hoverPrice.toFixed(4);
                    const textMetrics = this.overlayCtx.measureText(text);
                    const rectX = width - textMetrics.width - 10;
                    const rectY = Math.max(0, Math.min(height - 22, this.mouseY - 11));
                    this.overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.overlayCtx.fillRect(rectX, rectY, textMetrics.width + 10, 22);
                    this.overlayCtx.fillStyle = '#FFFF00';
                    this.overlayCtx.textBaseline = 'middle';
                    this.overlayCtx.fillText(text, width - 5, rectY + 11);
                }
            }
        }

        // --- MAIN APP LOGIC (formerly App component) ---
        document.addEventListener('DOMContentLoaded', () => {
            const dom = {
                searchInput: document.getElementById('symbol-search-input'),
                dropdown: document.getElementById('symbol-dropdown'),
                dropdownList: document.getElementById('symbol-dropdown-list'),
                connectBtn: document.getElementById('connect-button'),
                disconnectBtn: document.getElementById('disconnect-button'),
                frequencySelect: document.getElementById('frequency-select'),
                priceDisplay: document.getElementById('price-display'),
                symbolDisplay: document.getElementById('symbol-display'),
                vizTypeBtns: document.querySelectorAll('.viz-type-btn'),
                status: {
                    disconnected: document.getElementById('status-disconnected'),
                    connecting: document.getElementById('status-connecting'),
                    error: document.getElementById('status-error'),
                },
                connectingText: document.getElementById('connecting-text'),
                visualizerContainer: document.getElementById('visualizer-container'),
                infoBtn: document.getElementById('info-button'),
                infoModal: document.getElementById('info-modal'),
                closeModalBtn: document.getElementById('close-modal-button'),
            };

            let appState = {
                symbols: [],
                tickSizes: new Map(),
                selectedSymbol: '',
                visualizationType: 'walls',
            };

            const visualizer = new OrderBookVisualizer('canvas-parent');
            const orderBookManager = createOrderBookManager();

            const updateUI = (managerState) => {
                // Update status displays
                Object.values(dom.status).forEach(el => el.classList.add('hidden'));
                if (dom.status[managerState.status]) {
                    dom.status[managerState.status].classList.remove('hidden');
                }
                
                const isConnectingOrConnected = managerState.status === 'connecting' || managerState.status === 'connected';
                dom.searchInput.disabled = isConnectingOrConnected;
                dom.frequencySelect.disabled = isConnectingOrConnected;
                dom.connectBtn.classList.toggle('hidden', isConnectingOrConnected);
                dom.disconnectBtn.classList.toggle('hidden', !isConnectingOrConnected);
                dom.visualizerContainer.classList.toggle('hidden', managerState.status !== 'connected');

                if (managerState.status === 'connecting') {
                    dom.connectingText.textContent = `Connecting to ${appState.selectedSymbol} stream and building order book...`;
                }

                if (managerState.status === 'connected') {
                    dom.priceDisplay.textContent = managerState.currentPrice.toFixed(4);
                    dom.symbolDisplay.textContent = appState.selectedSymbol;
                    visualizer.render({ ...managerState, visualizationType: appState.visualizationType });
                }
            };
            
            orderBookManager.onUpdate(updateUI);

            const renderDropdown = (symbols) => {
                if (symbols.length === 0) {
                    dom.dropdownList.innerHTML = `<div class="px-3 py-2 text-gray-400 text-sm">No pairs found</div>`;
                    return;
                }
                dom.dropdownList.innerHTML = symbols.map(s => 
                    `<div class="px-3 py-2 text-sm cursor-pointer hover:bg-gray-700" data-symbol="${s}">${s}</div>`
                ).join('');
            };

            const fetchSymbols = async () => {
                try {
                    const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                    const data = await response.json();
                    const spotSymbols = data.symbols.filter(s => s.status === 'TRADING' && s.isSpotTradingAllowed);
                    
                    appState.symbols = spotSymbols.map(s => s.symbol);
                    spotSymbols.forEach(s => {
                        const priceFilter = s.filters.find(f => f.filterType === 'PRICE_FILTER');
                        if (priceFilter) {
                            appState.tickSizes.set(s.symbol, parseFloat(priceFilter.tickSize));
                        }
                    });
                    
                    renderDropdown(appState.symbols);
                    if (appState.symbols.length > 0) {
                        const defaultSymbol = appState.symbols.includes('BNBUSDC') ? 'BNBUSDC' : appState.symbols[0];
                        appState.selectedSymbol = defaultSymbol;
                        dom.searchInput.value = appState.selectedSymbol;
                    }
                } catch (error) {
                    console.error("Failed to fetch symbols:", error);
                }
            };
            
            dom.searchInput.addEventListener('focus', () => {
                renderDropdown(appState.symbols);
                dom.dropdown.classList.remove('hidden');
            });

            dom.searchInput.addEventListener('input', () => {
                const searchTerm = dom.searchInput.value.toUpperCase();
                const filteredSymbols = appState.symbols.filter(s => s.includes(searchTerm));
                renderDropdown(filteredSymbols);
                dom.dropdown.classList.remove('hidden');
            });

            dom.dropdownList.addEventListener('click', (e) => {
                if (e.target.dataset.symbol) {
                    appState.selectedSymbol = e.target.dataset.symbol;
                    dom.searchInput.value = appState.selectedSymbol;
                    dom.dropdown.classList.add('hidden');
                }
            });

            document.addEventListener('click', (e) => {
                const container = document.getElementById('symbol-search-container');
                if (!container.contains(e.target)) {
                    dom.dropdown.classList.add('hidden');
                    if (dom.searchInput.value !== appState.selectedSymbol) {
                        dom.searchInput.value = appState.selectedSymbol || '';
                    }
                }
            });

            dom.connectBtn.addEventListener('click', () => {
                if (appState.selectedSymbol) {
                    const tickSize = appState.tickSizes.get(appState.selectedSymbol) || 0.0001;
                    const frequency = dom.frequencySelect.value;
                    orderBookManager.connect(appState.selectedSymbol, appState.visualizationType, tickSize, frequency);
                }
            });

            dom.disconnectBtn.addEventListener('click', () => {
                orderBookManager.disconnect();
            });
            
            dom.vizTypeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    appState.visualizationType = btn.dataset.type;
                    dom.vizTypeBtns.forEach(b => {
                        b.classList.remove('bg-cyan-600', 'text-white');
                        b.classList.add('text-gray-300', 'hover:bg-gray-600');
                    });
                    btn.classList.add('bg-cyan-600', 'text-white');
                    btn.classList.remove('text-gray-300', 'hover:bg-gray-600');
                });
            });
            
            dom.infoBtn.addEventListener('click', () => {
                dom.infoModal.classList.remove('hidden');
            });

            dom.closeModalBtn.addEventListener('click', () => {
                dom.infoModal.classList.add('hidden');
            });
            
            dom.infoModal.addEventListener('click', (e) => {
                if (e.target === dom.infoModal) {
                    dom.infoModal.classList.add('hidden');
                }
            });

            fetchSymbols();
        });
    </script>
</body>
</html>